// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/eriner/burr/internal/ent/actor"
	"github.com/eriner/burr/internal/ent/event"
	"github.com/eriner/burr/internal/ent/predicate"
	"github.com/eriner/burr/internal/ent/server"
	"github.com/eriner/burr/internal/ent/session"
	"github.com/eriner/burr/internal/ent/status"
)

// ActorUpdate is the builder for updating Actor entities.
type ActorUpdate struct {
	config
	hooks    []Hook
	mutation *ActorMutation
}

// Where appends a list predicates to the ActorUpdate builder.
func (au *ActorUpdate) Where(ps ...predicate.Actor) *ActorUpdate {
	au.mutation.Where(ps...)
	return au
}

// SetUpdatedAt sets the "updated_at" field.
func (au *ActorUpdate) SetUpdatedAt(t time.Time) *ActorUpdate {
	au.mutation.SetUpdatedAt(t)
	return au
}

// SetCreatedBy sets the "created_by" field.
func (au *ActorUpdate) SetCreatedBy(i int) *ActorUpdate {
	au.mutation.ResetCreatedBy()
	au.mutation.SetCreatedBy(i)
	return au
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (au *ActorUpdate) SetNillableCreatedBy(i *int) *ActorUpdate {
	if i != nil {
		au.SetCreatedBy(*i)
	}
	return au
}

// AddCreatedBy adds i to the "created_by" field.
func (au *ActorUpdate) AddCreatedBy(i int) *ActorUpdate {
	au.mutation.AddCreatedBy(i)
	return au
}

// ClearCreatedBy clears the value of the "created_by" field.
func (au *ActorUpdate) ClearCreatedBy() *ActorUpdate {
	au.mutation.ClearCreatedBy()
	return au
}

// SetUpdatedBy sets the "updated_by" field.
func (au *ActorUpdate) SetUpdatedBy(i int) *ActorUpdate {
	au.mutation.ResetUpdatedBy()
	au.mutation.SetUpdatedBy(i)
	return au
}

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (au *ActorUpdate) SetNillableUpdatedBy(i *int) *ActorUpdate {
	if i != nil {
		au.SetUpdatedBy(*i)
	}
	return au
}

// AddUpdatedBy adds i to the "updated_by" field.
func (au *ActorUpdate) AddUpdatedBy(i int) *ActorUpdate {
	au.mutation.AddUpdatedBy(i)
	return au
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (au *ActorUpdate) ClearUpdatedBy() *ActorUpdate {
	au.mutation.ClearUpdatedBy()
	return au
}

// SetType sets the "type" field.
func (au *ActorUpdate) SetType(a actor.Type) *ActorUpdate {
	au.mutation.SetType(a)
	return au
}

// SetDisplayName sets the "display_name" field.
func (au *ActorUpdate) SetDisplayName(s string) *ActorUpdate {
	au.mutation.SetDisplayName(s)
	return au
}

// SetNillableDisplayName sets the "display_name" field if the given value is not nil.
func (au *ActorUpdate) SetNillableDisplayName(s *string) *ActorUpdate {
	if s != nil {
		au.SetDisplayName(*s)
	}
	return au
}

// SetNote sets the "note" field.
func (au *ActorUpdate) SetNote(s string) *ActorUpdate {
	au.mutation.SetNote(s)
	return au
}

// SetNillableNote sets the "note" field if the given value is not nil.
func (au *ActorUpdate) SetNillableNote(s *string) *ActorUpdate {
	if s != nil {
		au.SetNote(*s)
	}
	return au
}

// SetLocked sets the "locked" field.
func (au *ActorUpdate) SetLocked(b bool) *ActorUpdate {
	au.mutation.SetLocked(b)
	return au
}

// SetNillableLocked sets the "locked" field if the given value is not nil.
func (au *ActorUpdate) SetNillableLocked(b *bool) *ActorUpdate {
	if b != nil {
		au.SetLocked(*b)
	}
	return au
}

// SetMemorial sets the "memorial" field.
func (au *ActorUpdate) SetMemorial(b bool) *ActorUpdate {
	au.mutation.SetMemorial(b)
	return au
}

// SetNillableMemorial sets the "memorial" field if the given value is not nil.
func (au *ActorUpdate) SetNillableMemorial(b *bool) *ActorUpdate {
	if b != nil {
		au.SetMemorial(*b)
	}
	return au
}

// SetURL sets the "url" field.
func (au *ActorUpdate) SetURL(s string) *ActorUpdate {
	au.mutation.SetURL(s)
	return au
}

// SetPubkey sets the "pubkey" field.
func (au *ActorUpdate) SetPubkey(b []byte) *ActorUpdate {
	au.mutation.SetPubkey(b)
	return au
}

// SetPrivkey sets the "privkey" field.
func (au *ActorUpdate) SetPrivkey(b []byte) *ActorUpdate {
	au.mutation.SetPrivkey(b)
	return au
}

// ClearPrivkey clears the value of the "privkey" field.
func (au *ActorUpdate) ClearPrivkey() *ActorUpdate {
	au.mutation.ClearPrivkey()
	return au
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (au *ActorUpdate) SetAvatarRemoteURL(s string) *ActorUpdate {
	au.mutation.SetAvatarRemoteURL(s)
	return au
}

// SetNillableAvatarRemoteURL sets the "avatar_remote_url" field if the given value is not nil.
func (au *ActorUpdate) SetNillableAvatarRemoteURL(s *string) *ActorUpdate {
	if s != nil {
		au.SetAvatarRemoteURL(*s)
	}
	return au
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (au *ActorUpdate) ClearAvatarRemoteURL() *ActorUpdate {
	au.mutation.ClearAvatarRemoteURL()
	return au
}

// SetAvatarLocalFile sets the "avatar_local_file" field.
func (au *ActorUpdate) SetAvatarLocalFile(s string) *ActorUpdate {
	au.mutation.SetAvatarLocalFile(s)
	return au
}

// SetNillableAvatarLocalFile sets the "avatar_local_file" field if the given value is not nil.
func (au *ActorUpdate) SetNillableAvatarLocalFile(s *string) *ActorUpdate {
	if s != nil {
		au.SetAvatarLocalFile(*s)
	}
	return au
}

// ClearAvatarLocalFile clears the value of the "avatar_local_file" field.
func (au *ActorUpdate) ClearAvatarLocalFile() *ActorUpdate {
	au.mutation.ClearAvatarLocalFile()
	return au
}

// SetAvatarUpdatedAt sets the "avatar_updated_at" field.
func (au *ActorUpdate) SetAvatarUpdatedAt(t time.Time) *ActorUpdate {
	au.mutation.SetAvatarUpdatedAt(t)
	return au
}

// SetNillableAvatarUpdatedAt sets the "avatar_updated_at" field if the given value is not nil.
func (au *ActorUpdate) SetNillableAvatarUpdatedAt(t *time.Time) *ActorUpdate {
	if t != nil {
		au.SetAvatarUpdatedAt(*t)
	}
	return au
}

// ClearAvatarUpdatedAt clears the value of the "avatar_updated_at" field.
func (au *ActorUpdate) ClearAvatarUpdatedAt() *ActorUpdate {
	au.mutation.ClearAvatarUpdatedAt()
	return au
}

// SetHeaderURL sets the "header_url" field.
func (au *ActorUpdate) SetHeaderURL(s string) *ActorUpdate {
	au.mutation.SetHeaderURL(s)
	return au
}

// SetNillableHeaderURL sets the "header_url" field if the given value is not nil.
func (au *ActorUpdate) SetNillableHeaderURL(s *string) *ActorUpdate {
	if s != nil {
		au.SetHeaderURL(*s)
	}
	return au
}

// ClearHeaderURL clears the value of the "header_url" field.
func (au *ActorUpdate) ClearHeaderURL() *ActorUpdate {
	au.mutation.ClearHeaderURL()
	return au
}

// SetHeaderLocalFile sets the "header_local_file" field.
func (au *ActorUpdate) SetHeaderLocalFile(s string) *ActorUpdate {
	au.mutation.SetHeaderLocalFile(s)
	return au
}

// SetNillableHeaderLocalFile sets the "header_local_file" field if the given value is not nil.
func (au *ActorUpdate) SetNillableHeaderLocalFile(s *string) *ActorUpdate {
	if s != nil {
		au.SetHeaderLocalFile(*s)
	}
	return au
}

// ClearHeaderLocalFile clears the value of the "header_local_file" field.
func (au *ActorUpdate) ClearHeaderLocalFile() *ActorUpdate {
	au.mutation.ClearHeaderLocalFile()
	return au
}

// SetHeaderUpdatedAt sets the "header_updated_at" field.
func (au *ActorUpdate) SetHeaderUpdatedAt(t time.Time) *ActorUpdate {
	au.mutation.SetHeaderUpdatedAt(t)
	return au
}

// SetNillableHeaderUpdatedAt sets the "header_updated_at" field if the given value is not nil.
func (au *ActorUpdate) SetNillableHeaderUpdatedAt(t *time.Time) *ActorUpdate {
	if t != nil {
		au.SetHeaderUpdatedAt(*t)
	}
	return au
}

// ClearHeaderUpdatedAt clears the value of the "header_updated_at" field.
func (au *ActorUpdate) ClearHeaderUpdatedAt() *ActorUpdate {
	au.mutation.ClearHeaderUpdatedAt()
	return au
}

// SetLastWebfingerAt sets the "last_webfinger_at" field.
func (au *ActorUpdate) SetLastWebfingerAt(t time.Time) *ActorUpdate {
	au.mutation.SetLastWebfingerAt(t)
	return au
}

// SetNillableLastWebfingerAt sets the "last_webfinger_at" field if the given value is not nil.
func (au *ActorUpdate) SetNillableLastWebfingerAt(t *time.Time) *ActorUpdate {
	if t != nil {
		au.SetLastWebfingerAt(*t)
	}
	return au
}

// ClearLastWebfingerAt clears the value of the "last_webfinger_at" field.
func (au *ActorUpdate) ClearLastWebfingerAt() *ActorUpdate {
	au.mutation.ClearLastWebfingerAt()
	return au
}

// SetInboxURL sets the "inbox_url" field.
func (au *ActorUpdate) SetInboxURL(s string) *ActorUpdate {
	au.mutation.SetInboxURL(s)
	return au
}

// SetOutboxURL sets the "outbox_url" field.
func (au *ActorUpdate) SetOutboxURL(s string) *ActorUpdate {
	au.mutation.SetOutboxURL(s)
	return au
}

// SetSharedInboxURL sets the "shared_inbox_url" field.
func (au *ActorUpdate) SetSharedInboxURL(s string) *ActorUpdate {
	au.mutation.SetSharedInboxURL(s)
	return au
}

// SetFollowersURL sets the "followers_url" field.
func (au *ActorUpdate) SetFollowersURL(s string) *ActorUpdate {
	au.mutation.SetFollowersURL(s)
	return au
}

// SetMovedToID sets the "moved_to_id" field.
func (au *ActorUpdate) SetMovedToID(u uint64) *ActorUpdate {
	au.mutation.ResetMovedToID()
	au.mutation.SetMovedToID(u)
	return au
}

// SetNillableMovedToID sets the "moved_to_id" field if the given value is not nil.
func (au *ActorUpdate) SetNillableMovedToID(u *uint64) *ActorUpdate {
	if u != nil {
		au.SetMovedToID(*u)
	}
	return au
}

// AddMovedToID adds u to the "moved_to_id" field.
func (au *ActorUpdate) AddMovedToID(u int64) *ActorUpdate {
	au.mutation.AddMovedToID(u)
	return au
}

// ClearMovedToID clears the value of the "moved_to_id" field.
func (au *ActorUpdate) ClearMovedToID() *ActorUpdate {
	au.mutation.ClearMovedToID()
	return au
}

// SetFeaturedCollectionURL sets the "featured_collection_url" field.
func (au *ActorUpdate) SetFeaturedCollectionURL(s string) *ActorUpdate {
	au.mutation.SetFeaturedCollectionURL(s)
	return au
}

// SetNillableFeaturedCollectionURL sets the "featured_collection_url" field if the given value is not nil.
func (au *ActorUpdate) SetNillableFeaturedCollectionURL(s *string) *ActorUpdate {
	if s != nil {
		au.SetFeaturedCollectionURL(*s)
	}
	return au
}

// ClearFeaturedCollectionURL clears the value of the "featured_collection_url" field.
func (au *ActorUpdate) ClearFeaturedCollectionURL() *ActorUpdate {
	au.mutation.ClearFeaturedCollectionURL()
	return au
}

// SetSilencedAt sets the "silenced_at" field.
func (au *ActorUpdate) SetSilencedAt(t time.Time) *ActorUpdate {
	au.mutation.SetSilencedAt(t)
	return au
}

// SetNillableSilencedAt sets the "silenced_at" field if the given value is not nil.
func (au *ActorUpdate) SetNillableSilencedAt(t *time.Time) *ActorUpdate {
	if t != nil {
		au.SetSilencedAt(*t)
	}
	return au
}

// ClearSilencedAt clears the value of the "silenced_at" field.
func (au *ActorUpdate) ClearSilencedAt() *ActorUpdate {
	au.mutation.ClearSilencedAt()
	return au
}

// SetSuspendedAt sets the "suspended_at" field.
func (au *ActorUpdate) SetSuspendedAt(t time.Time) *ActorUpdate {
	au.mutation.SetSuspendedAt(t)
	return au
}

// SetNillableSuspendedAt sets the "suspended_at" field if the given value is not nil.
func (au *ActorUpdate) SetNillableSuspendedAt(t *time.Time) *ActorUpdate {
	if t != nil {
		au.SetSuspendedAt(*t)
	}
	return au
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (au *ActorUpdate) ClearSuspendedAt() *ActorUpdate {
	au.mutation.ClearSuspendedAt()
	return au
}

// SetPasswordHash sets the "passwordHash" field.
func (au *ActorUpdate) SetPasswordHash(b []byte) *ActorUpdate {
	au.mutation.SetPasswordHash(b)
	return au
}

// ClearPasswordHash clears the value of the "passwordHash" field.
func (au *ActorUpdate) ClearPasswordHash() *ActorUpdate {
	au.mutation.ClearPasswordHash()
	return au
}

// SetRecoveryCode sets the "recovery_code" field.
func (au *ActorUpdate) SetRecoveryCode(s string) *ActorUpdate {
	au.mutation.SetRecoveryCode(s)
	return au
}

// SetNillableRecoveryCode sets the "recovery_code" field if the given value is not nil.
func (au *ActorUpdate) SetNillableRecoveryCode(s *string) *ActorUpdate {
	if s != nil {
		au.SetRecoveryCode(*s)
	}
	return au
}

// ClearRecoveryCode clears the value of the "recovery_code" field.
func (au *ActorUpdate) ClearRecoveryCode() *ActorUpdate {
	au.mutation.ClearRecoveryCode()
	return au
}

// SetRole sets the "role" field.
func (au *ActorUpdate) SetRole(u uint64) *ActorUpdate {
	au.mutation.ResetRole()
	au.mutation.SetRole(u)
	return au
}

// SetNillableRole sets the "role" field if the given value is not nil.
func (au *ActorUpdate) SetNillableRole(u *uint64) *ActorUpdate {
	if u != nil {
		au.SetRole(*u)
	}
	return au
}

// AddRole adds u to the "role" field.
func (au *ActorUpdate) AddRole(u int64) *ActorUpdate {
	au.mutation.AddRole(u)
	return au
}

// ClearRole clears the value of the "role" field.
func (au *ActorUpdate) ClearRole() *ActorUpdate {
	au.mutation.ClearRole()
	return au
}

// SetBadge sets the "badge" field.
func (au *ActorUpdate) SetBadge(u uint64) *ActorUpdate {
	au.mutation.ResetBadge()
	au.mutation.SetBadge(u)
	return au
}

// SetNillableBadge sets the "badge" field if the given value is not nil.
func (au *ActorUpdate) SetNillableBadge(u *uint64) *ActorUpdate {
	if u != nil {
		au.SetBadge(*u)
	}
	return au
}

// AddBadge adds u to the "badge" field.
func (au *ActorUpdate) AddBadge(u int64) *ActorUpdate {
	au.mutation.AddBadge(u)
	return au
}

// ClearBadge clears the value of the "badge" field.
func (au *ActorUpdate) ClearBadge() *ActorUpdate {
	au.mutation.ClearBadge()
	return au
}

// SetLocale sets the "locale" field.
func (au *ActorUpdate) SetLocale(a actor.Locale) *ActorUpdate {
	au.mutation.SetLocale(a)
	return au
}

// SetServerID sets the "server" edge to the Server entity by ID.
func (au *ActorUpdate) SetServerID(id uint64) *ActorUpdate {
	au.mutation.SetServerID(id)
	return au
}

// SetServer sets the "server" edge to the Server entity.
func (au *ActorUpdate) SetServer(s *Server) *ActorUpdate {
	return au.SetServerID(s.ID)
}

// AddEventIDs adds the "events" edge to the Event entity by IDs.
func (au *ActorUpdate) AddEventIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddEventIDs(ids...)
	return au
}

// AddEvents adds the "events" edges to the Event entity.
func (au *ActorUpdate) AddEvents(e ...*Event) *ActorUpdate {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return au.AddEventIDs(ids...)
}

// AddOrganizerOfIDs adds the "organizer_of" edge to the Event entity by IDs.
func (au *ActorUpdate) AddOrganizerOfIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddOrganizerOfIDs(ids...)
	return au
}

// AddOrganizerOf adds the "organizer_of" edges to the Event entity.
func (au *ActorUpdate) AddOrganizerOf(e ...*Event) *ActorUpdate {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return au.AddOrganizerOfIDs(ids...)
}

// AddStatusIDs adds the "statuses" edge to the Status entity by IDs.
func (au *ActorUpdate) AddStatusIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddStatusIDs(ids...)
	return au
}

// AddStatuses adds the "statuses" edges to the Status entity.
func (au *ActorUpdate) AddStatuses(s ...*Status) *ActorUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.AddStatusIDs(ids...)
}

// AddFollowerIDs adds the "followers" edge to the Actor entity by IDs.
func (au *ActorUpdate) AddFollowerIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddFollowerIDs(ids...)
	return au
}

// AddFollowers adds the "followers" edges to the Actor entity.
func (au *ActorUpdate) AddFollowers(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddFollowerIDs(ids...)
}

// AddFollowingIDs adds the "following" edge to the Actor entity by IDs.
func (au *ActorUpdate) AddFollowingIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddFollowingIDs(ids...)
	return au
}

// AddFollowing adds the "following" edges to the Actor entity.
func (au *ActorUpdate) AddFollowing(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddFollowingIDs(ids...)
}

// AddReactedStatusIDs adds the "reacted_statuses" edge to the Status entity by IDs.
func (au *ActorUpdate) AddReactedStatusIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddReactedStatusIDs(ids...)
	return au
}

// AddReactedStatuses adds the "reacted_statuses" edges to the Status entity.
func (au *ActorUpdate) AddReactedStatuses(s ...*Status) *ActorUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.AddReactedStatusIDs(ids...)
}

// AddModeratorIDs adds the "moderators" edge to the Actor entity by IDs.
func (au *ActorUpdate) AddModeratorIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddModeratorIDs(ids...)
	return au
}

// AddModerators adds the "moderators" edges to the Actor entity.
func (au *ActorUpdate) AddModerators(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddModeratorIDs(ids...)
}

// AddModeratingIDs adds the "moderating" edge to the Actor entity by IDs.
func (au *ActorUpdate) AddModeratingIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddModeratingIDs(ids...)
	return au
}

// AddModerating adds the "moderating" edges to the Actor entity.
func (au *ActorUpdate) AddModerating(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddModeratingIDs(ids...)
}

// AddMemberIDs adds the "members" edge to the Actor entity by IDs.
func (au *ActorUpdate) AddMemberIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddMemberIDs(ids...)
	return au
}

// AddMembers adds the "members" edges to the Actor entity.
func (au *ActorUpdate) AddMembers(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddMemberIDs(ids...)
}

// AddGroupIDs adds the "groups" edge to the Actor entity by IDs.
func (au *ActorUpdate) AddGroupIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddGroupIDs(ids...)
	return au
}

// AddGroups adds the "groups" edges to the Actor entity.
func (au *ActorUpdate) AddGroups(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.AddGroupIDs(ids...)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by IDs.
func (au *ActorUpdate) AddSessionIDs(ids ...uint64) *ActorUpdate {
	au.mutation.AddSessionIDs(ids...)
	return au
}

// AddSessions adds the "sessions" edges to the Session entity.
func (au *ActorUpdate) AddSessions(s ...*Session) *ActorUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.AddSessionIDs(ids...)
}

// Mutation returns the ActorMutation object of the builder.
func (au *ActorUpdate) Mutation() *ActorMutation {
	return au.mutation
}

// ClearServer clears the "server" edge to the Server entity.
func (au *ActorUpdate) ClearServer() *ActorUpdate {
	au.mutation.ClearServer()
	return au
}

// ClearEvents clears all "events" edges to the Event entity.
func (au *ActorUpdate) ClearEvents() *ActorUpdate {
	au.mutation.ClearEvents()
	return au
}

// RemoveEventIDs removes the "events" edge to Event entities by IDs.
func (au *ActorUpdate) RemoveEventIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveEventIDs(ids...)
	return au
}

// RemoveEvents removes "events" edges to Event entities.
func (au *ActorUpdate) RemoveEvents(e ...*Event) *ActorUpdate {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return au.RemoveEventIDs(ids...)
}

// ClearOrganizerOf clears all "organizer_of" edges to the Event entity.
func (au *ActorUpdate) ClearOrganizerOf() *ActorUpdate {
	au.mutation.ClearOrganizerOf()
	return au
}

// RemoveOrganizerOfIDs removes the "organizer_of" edge to Event entities by IDs.
func (au *ActorUpdate) RemoveOrganizerOfIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveOrganizerOfIDs(ids...)
	return au
}

// RemoveOrganizerOf removes "organizer_of" edges to Event entities.
func (au *ActorUpdate) RemoveOrganizerOf(e ...*Event) *ActorUpdate {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return au.RemoveOrganizerOfIDs(ids...)
}

// ClearStatuses clears all "statuses" edges to the Status entity.
func (au *ActorUpdate) ClearStatuses() *ActorUpdate {
	au.mutation.ClearStatuses()
	return au
}

// RemoveStatusIDs removes the "statuses" edge to Status entities by IDs.
func (au *ActorUpdate) RemoveStatusIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveStatusIDs(ids...)
	return au
}

// RemoveStatuses removes "statuses" edges to Status entities.
func (au *ActorUpdate) RemoveStatuses(s ...*Status) *ActorUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.RemoveStatusIDs(ids...)
}

// ClearFollowers clears all "followers" edges to the Actor entity.
func (au *ActorUpdate) ClearFollowers() *ActorUpdate {
	au.mutation.ClearFollowers()
	return au
}

// RemoveFollowerIDs removes the "followers" edge to Actor entities by IDs.
func (au *ActorUpdate) RemoveFollowerIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveFollowerIDs(ids...)
	return au
}

// RemoveFollowers removes "followers" edges to Actor entities.
func (au *ActorUpdate) RemoveFollowers(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveFollowerIDs(ids...)
}

// ClearFollowing clears all "following" edges to the Actor entity.
func (au *ActorUpdate) ClearFollowing() *ActorUpdate {
	au.mutation.ClearFollowing()
	return au
}

// RemoveFollowingIDs removes the "following" edge to Actor entities by IDs.
func (au *ActorUpdate) RemoveFollowingIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveFollowingIDs(ids...)
	return au
}

// RemoveFollowing removes "following" edges to Actor entities.
func (au *ActorUpdate) RemoveFollowing(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveFollowingIDs(ids...)
}

// ClearReactedStatuses clears all "reacted_statuses" edges to the Status entity.
func (au *ActorUpdate) ClearReactedStatuses() *ActorUpdate {
	au.mutation.ClearReactedStatuses()
	return au
}

// RemoveReactedStatusIDs removes the "reacted_statuses" edge to Status entities by IDs.
func (au *ActorUpdate) RemoveReactedStatusIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveReactedStatusIDs(ids...)
	return au
}

// RemoveReactedStatuses removes "reacted_statuses" edges to Status entities.
func (au *ActorUpdate) RemoveReactedStatuses(s ...*Status) *ActorUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.RemoveReactedStatusIDs(ids...)
}

// ClearModerators clears all "moderators" edges to the Actor entity.
func (au *ActorUpdate) ClearModerators() *ActorUpdate {
	au.mutation.ClearModerators()
	return au
}

// RemoveModeratorIDs removes the "moderators" edge to Actor entities by IDs.
func (au *ActorUpdate) RemoveModeratorIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveModeratorIDs(ids...)
	return au
}

// RemoveModerators removes "moderators" edges to Actor entities.
func (au *ActorUpdate) RemoveModerators(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveModeratorIDs(ids...)
}

// ClearModerating clears all "moderating" edges to the Actor entity.
func (au *ActorUpdate) ClearModerating() *ActorUpdate {
	au.mutation.ClearModerating()
	return au
}

// RemoveModeratingIDs removes the "moderating" edge to Actor entities by IDs.
func (au *ActorUpdate) RemoveModeratingIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveModeratingIDs(ids...)
	return au
}

// RemoveModerating removes "moderating" edges to Actor entities.
func (au *ActorUpdate) RemoveModerating(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveModeratingIDs(ids...)
}

// ClearMembers clears all "members" edges to the Actor entity.
func (au *ActorUpdate) ClearMembers() *ActorUpdate {
	au.mutation.ClearMembers()
	return au
}

// RemoveMemberIDs removes the "members" edge to Actor entities by IDs.
func (au *ActorUpdate) RemoveMemberIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveMemberIDs(ids...)
	return au
}

// RemoveMembers removes "members" edges to Actor entities.
func (au *ActorUpdate) RemoveMembers(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveMemberIDs(ids...)
}

// ClearGroups clears all "groups" edges to the Actor entity.
func (au *ActorUpdate) ClearGroups() *ActorUpdate {
	au.mutation.ClearGroups()
	return au
}

// RemoveGroupIDs removes the "groups" edge to Actor entities by IDs.
func (au *ActorUpdate) RemoveGroupIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveGroupIDs(ids...)
	return au
}

// RemoveGroups removes "groups" edges to Actor entities.
func (au *ActorUpdate) RemoveGroups(a ...*Actor) *ActorUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return au.RemoveGroupIDs(ids...)
}

// ClearSessions clears all "sessions" edges to the Session entity.
func (au *ActorUpdate) ClearSessions() *ActorUpdate {
	au.mutation.ClearSessions()
	return au
}

// RemoveSessionIDs removes the "sessions" edge to Session entities by IDs.
func (au *ActorUpdate) RemoveSessionIDs(ids ...uint64) *ActorUpdate {
	au.mutation.RemoveSessionIDs(ids...)
	return au
}

// RemoveSessions removes "sessions" edges to Session entities.
func (au *ActorUpdate) RemoveSessions(s ...*Session) *ActorUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.RemoveSessionIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (au *ActorUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	if err := au.defaults(); err != nil {
		return 0, err
	}
	if len(au.hooks) == 0 {
		if err = au.check(); err != nil {
			return 0, err
		}
		affected, err = au.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ActorMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = au.check(); err != nil {
				return 0, err
			}
			au.mutation = mutation
			affected, err = au.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(au.hooks) - 1; i >= 0; i-- {
			if au.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = au.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, au.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (au *ActorUpdate) SaveX(ctx context.Context) int {
	affected, err := au.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (au *ActorUpdate) Exec(ctx context.Context) error {
	_, err := au.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (au *ActorUpdate) ExecX(ctx context.Context) {
	if err := au.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (au *ActorUpdate) defaults() error {
	if _, ok := au.mutation.UpdatedAt(); !ok {
		if actor.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("ent: uninitialized actor.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
		}
		v := actor.UpdateDefaultUpdatedAt()
		au.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (au *ActorUpdate) check() error {
	if v, ok := au.mutation.GetType(); ok {
		if err := actor.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Actor.type": %w`, err)}
		}
	}
	if v, ok := au.mutation.DisplayName(); ok {
		if err := actor.DisplayNameValidator(v); err != nil {
			return &ValidationError{Name: "display_name", err: fmt.Errorf(`ent: validator failed for field "Actor.display_name": %w`, err)}
		}
	}
	if v, ok := au.mutation.Note(); ok {
		if err := actor.NoteValidator(v); err != nil {
			return &ValidationError{Name: "note", err: fmt.Errorf(`ent: validator failed for field "Actor.note": %w`, err)}
		}
	}
	if v, ok := au.mutation.URL(); ok {
		if err := actor.URLValidator(v); err != nil {
			return &ValidationError{Name: "url", err: fmt.Errorf(`ent: validator failed for field "Actor.url": %w`, err)}
		}
	}
	if v, ok := au.mutation.Pubkey(); ok {
		if err := actor.PubkeyValidator(v); err != nil {
			return &ValidationError{Name: "pubkey", err: fmt.Errorf(`ent: validator failed for field "Actor.pubkey": %w`, err)}
		}
	}
	if v, ok := au.mutation.AvatarRemoteURL(); ok {
		if err := actor.AvatarRemoteURLValidator(v); err != nil {
			return &ValidationError{Name: "avatar_remote_url", err: fmt.Errorf(`ent: validator failed for field "Actor.avatar_remote_url": %w`, err)}
		}
	}
	if v, ok := au.mutation.AvatarLocalFile(); ok {
		if err := actor.AvatarLocalFileValidator(v); err != nil {
			return &ValidationError{Name: "avatar_local_file", err: fmt.Errorf(`ent: validator failed for field "Actor.avatar_local_file": %w`, err)}
		}
	}
	if v, ok := au.mutation.HeaderURL(); ok {
		if err := actor.HeaderURLValidator(v); err != nil {
			return &ValidationError{Name: "header_url", err: fmt.Errorf(`ent: validator failed for field "Actor.header_url": %w`, err)}
		}
	}
	if v, ok := au.mutation.HeaderLocalFile(); ok {
		if err := actor.HeaderLocalFileValidator(v); err != nil {
			return &ValidationError{Name: "header_local_file", err: fmt.Errorf(`ent: validator failed for field "Actor.header_local_file": %w`, err)}
		}
	}
	if v, ok := au.mutation.InboxURL(); ok {
		if err := actor.InboxURLValidator(v); err != nil {
			return &ValidationError{Name: "inbox_url", err: fmt.Errorf(`ent: validator failed for field "Actor.inbox_url": %w`, err)}
		}
	}
	if v, ok := au.mutation.OutboxURL(); ok {
		if err := actor.OutboxURLValidator(v); err != nil {
			return &ValidationError{Name: "outbox_url", err: fmt.Errorf(`ent: validator failed for field "Actor.outbox_url": %w`, err)}
		}
	}
	if v, ok := au.mutation.SharedInboxURL(); ok {
		if err := actor.SharedInboxURLValidator(v); err != nil {
			return &ValidationError{Name: "shared_inbox_url", err: fmt.Errorf(`ent: validator failed for field "Actor.shared_inbox_url": %w`, err)}
		}
	}
	if v, ok := au.mutation.FollowersURL(); ok {
		if err := actor.FollowersURLValidator(v); err != nil {
			return &ValidationError{Name: "followers_url", err: fmt.Errorf(`ent: validator failed for field "Actor.followers_url": %w`, err)}
		}
	}
	if v, ok := au.mutation.PasswordHash(); ok {
		if err := actor.PasswordHashValidator(v); err != nil {
			return &ValidationError{Name: "passwordHash", err: fmt.Errorf(`ent: validator failed for field "Actor.passwordHash": %w`, err)}
		}
	}
	if v, ok := au.mutation.Locale(); ok {
		if err := actor.LocaleValidator(v); err != nil {
			return &ValidationError{Name: "locale", err: fmt.Errorf(`ent: validator failed for field "Actor.locale": %w`, err)}
		}
	}
	if _, ok := au.mutation.ServerID(); au.mutation.ServerCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "Actor.server"`)
	}
	return nil
}

func (au *ActorUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   actor.Table,
			Columns: actor.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUint64,
				Column: actor.FieldID,
			},
		},
	}
	if ps := au.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := au.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldUpdatedAt,
		})
	}
	if value, ok := au.mutation.CreatedBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldCreatedBy,
		})
	}
	if value, ok := au.mutation.AddedCreatedBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldCreatedBy,
		})
	}
	if au.mutation.CreatedByCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: actor.FieldCreatedBy,
		})
	}
	if value, ok := au.mutation.UpdatedBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldUpdatedBy,
		})
	}
	if value, ok := au.mutation.AddedUpdatedBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldUpdatedBy,
		})
	}
	if au.mutation.UpdatedByCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: actor.FieldUpdatedBy,
		})
	}
	if value, ok := au.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: actor.FieldType,
		})
	}
	if value, ok := au.mutation.DisplayName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldDisplayName,
		})
	}
	if value, ok := au.mutation.Note(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldNote,
		})
	}
	if value, ok := au.mutation.Locked(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: actor.FieldLocked,
		})
	}
	if value, ok := au.mutation.Memorial(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: actor.FieldMemorial,
		})
	}
	if value, ok := au.mutation.URL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldURL,
		})
	}
	if value, ok := au.mutation.Pubkey(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Value:  value,
			Column: actor.FieldPubkey,
		})
	}
	if value, ok := au.mutation.Privkey(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Value:  value,
			Column: actor.FieldPrivkey,
		})
	}
	if au.mutation.PrivkeyCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Column: actor.FieldPrivkey,
		})
	}
	if value, ok := au.mutation.AvatarRemoteURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldAvatarRemoteURL,
		})
	}
	if au.mutation.AvatarRemoteURLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldAvatarRemoteURL,
		})
	}
	if value, ok := au.mutation.AvatarLocalFile(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldAvatarLocalFile,
		})
	}
	if au.mutation.AvatarLocalFileCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldAvatarLocalFile,
		})
	}
	if value, ok := au.mutation.AvatarUpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldAvatarUpdatedAt,
		})
	}
	if au.mutation.AvatarUpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldAvatarUpdatedAt,
		})
	}
	if value, ok := au.mutation.HeaderURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldHeaderURL,
		})
	}
	if au.mutation.HeaderURLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldHeaderURL,
		})
	}
	if value, ok := au.mutation.HeaderLocalFile(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldHeaderLocalFile,
		})
	}
	if au.mutation.HeaderLocalFileCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldHeaderLocalFile,
		})
	}
	if value, ok := au.mutation.HeaderUpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldHeaderUpdatedAt,
		})
	}
	if au.mutation.HeaderUpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldHeaderUpdatedAt,
		})
	}
	if value, ok := au.mutation.LastWebfingerAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldLastWebfingerAt,
		})
	}
	if au.mutation.LastWebfingerAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldLastWebfingerAt,
		})
	}
	if value, ok := au.mutation.InboxURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldInboxURL,
		})
	}
	if value, ok := au.mutation.OutboxURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldOutboxURL,
		})
	}
	if value, ok := au.mutation.SharedInboxURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldSharedInboxURL,
		})
	}
	if value, ok := au.mutation.FollowersURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldFollowersURL,
		})
	}
	if value, ok := au.mutation.MovedToID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldMovedToID,
		})
	}
	if value, ok := au.mutation.AddedMovedToID(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldMovedToID,
		})
	}
	if au.mutation.MovedToIDCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Column: actor.FieldMovedToID,
		})
	}
	if value, ok := au.mutation.FeaturedCollectionURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldFeaturedCollectionURL,
		})
	}
	if au.mutation.FeaturedCollectionURLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldFeaturedCollectionURL,
		})
	}
	if value, ok := au.mutation.SilencedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldSilencedAt,
		})
	}
	if au.mutation.SilencedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldSilencedAt,
		})
	}
	if value, ok := au.mutation.SuspendedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldSuspendedAt,
		})
	}
	if au.mutation.SuspendedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldSuspendedAt,
		})
	}
	if value, ok := au.mutation.PasswordHash(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Value:  value,
			Column: actor.FieldPasswordHash,
		})
	}
	if au.mutation.PasswordHashCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Column: actor.FieldPasswordHash,
		})
	}
	if value, ok := au.mutation.RecoveryCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldRecoveryCode,
		})
	}
	if au.mutation.RecoveryCodeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldRecoveryCode,
		})
	}
	if value, ok := au.mutation.Role(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldRole,
		})
	}
	if value, ok := au.mutation.AddedRole(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldRole,
		})
	}
	if au.mutation.RoleCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Column: actor.FieldRole,
		})
	}
	if value, ok := au.mutation.Badge(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldBadge,
		})
	}
	if value, ok := au.mutation.AddedBadge(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldBadge,
		})
	}
	if au.mutation.BadgeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Column: actor.FieldBadge,
		})
	}
	if value, ok := au.mutation.Locale(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: actor.FieldLocale,
		})
	}
	if au.mutation.ServerCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   actor.ServerTable,
			Columns: []string{actor.ServerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: server.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.ServerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   actor.ServerTable,
			Columns: []string{actor.ServerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: server.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.EventsTable,
			Columns: actor.EventsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedEventsIDs(); len(nodes) > 0 && !au.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.EventsTable,
			Columns: actor.EventsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.EventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.EventsTable,
			Columns: actor.EventsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.OrganizerOfCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.OrganizerOfTable,
			Columns: []string{actor.OrganizerOfColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedOrganizerOfIDs(); len(nodes) > 0 && !au.mutation.OrganizerOfCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.OrganizerOfTable,
			Columns: []string{actor.OrganizerOfColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.OrganizerOfIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.OrganizerOfTable,
			Columns: []string{actor.OrganizerOfColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.StatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.StatusesTable,
			Columns: []string{actor.StatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedStatusesIDs(); len(nodes) > 0 && !au.mutation.StatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.StatusesTable,
			Columns: []string{actor.StatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.StatusesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.StatusesTable,
			Columns: []string{actor.StatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.FollowersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.FollowersTable,
			Columns: actor.FollowersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedFollowersIDs(); len(nodes) > 0 && !au.mutation.FollowersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.FollowersTable,
			Columns: actor.FollowersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.FollowersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.FollowersTable,
			Columns: actor.FollowersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.FollowingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.FollowingTable,
			Columns: actor.FollowingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedFollowingIDs(); len(nodes) > 0 && !au.mutation.FollowingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.FollowingTable,
			Columns: actor.FollowingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.FollowingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.FollowingTable,
			Columns: actor.FollowingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.ReactedStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ReactedStatusesTable,
			Columns: actor.ReactedStatusesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		createE := &ReactionCreate{config: au.config, mutation: newReactionMutation(au.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedReactedStatusesIDs(); len(nodes) > 0 && !au.mutation.ReactedStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ReactedStatusesTable,
			Columns: actor.ReactedStatusesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: au.config, mutation: newReactionMutation(au.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.ReactedStatusesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ReactedStatusesTable,
			Columns: actor.ReactedStatusesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: au.config, mutation: newReactionMutation(au.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.ModeratorsTable,
			Columns: actor.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedModeratorsIDs(); len(nodes) > 0 && !au.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.ModeratorsTable,
			Columns: actor.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.ModeratorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.ModeratorsTable,
			Columns: actor.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.ModeratingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ModeratingTable,
			Columns: actor.ModeratingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedModeratingIDs(); len(nodes) > 0 && !au.mutation.ModeratingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ModeratingTable,
			Columns: actor.ModeratingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.ModeratingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ModeratingTable,
			Columns: actor.ModeratingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.MembersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.MembersTable,
			Columns: actor.MembersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedMembersIDs(); len(nodes) > 0 && !au.mutation.MembersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.MembersTable,
			Columns: actor.MembersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.MembersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.MembersTable,
			Columns: actor.MembersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.GroupsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.GroupsTable,
			Columns: actor.GroupsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedGroupsIDs(); len(nodes) > 0 && !au.mutation.GroupsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.GroupsTable,
			Columns: actor.GroupsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.GroupsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.GroupsTable,
			Columns: actor.GroupsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.SessionsTable,
			Columns: []string{actor.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: session.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedSessionsIDs(); len(nodes) > 0 && !au.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.SessionsTable,
			Columns: []string{actor.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: session.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.SessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.SessionsTable,
			Columns: []string{actor.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: session.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, au.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{actor.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	return n, nil
}

// ActorUpdateOne is the builder for updating a single Actor entity.
type ActorUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ActorMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (auo *ActorUpdateOne) SetUpdatedAt(t time.Time) *ActorUpdateOne {
	auo.mutation.SetUpdatedAt(t)
	return auo
}

// SetCreatedBy sets the "created_by" field.
func (auo *ActorUpdateOne) SetCreatedBy(i int) *ActorUpdateOne {
	auo.mutation.ResetCreatedBy()
	auo.mutation.SetCreatedBy(i)
	return auo
}

// SetNillableCreatedBy sets the "created_by" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableCreatedBy(i *int) *ActorUpdateOne {
	if i != nil {
		auo.SetCreatedBy(*i)
	}
	return auo
}

// AddCreatedBy adds i to the "created_by" field.
func (auo *ActorUpdateOne) AddCreatedBy(i int) *ActorUpdateOne {
	auo.mutation.AddCreatedBy(i)
	return auo
}

// ClearCreatedBy clears the value of the "created_by" field.
func (auo *ActorUpdateOne) ClearCreatedBy() *ActorUpdateOne {
	auo.mutation.ClearCreatedBy()
	return auo
}

// SetUpdatedBy sets the "updated_by" field.
func (auo *ActorUpdateOne) SetUpdatedBy(i int) *ActorUpdateOne {
	auo.mutation.ResetUpdatedBy()
	auo.mutation.SetUpdatedBy(i)
	return auo
}

// SetNillableUpdatedBy sets the "updated_by" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableUpdatedBy(i *int) *ActorUpdateOne {
	if i != nil {
		auo.SetUpdatedBy(*i)
	}
	return auo
}

// AddUpdatedBy adds i to the "updated_by" field.
func (auo *ActorUpdateOne) AddUpdatedBy(i int) *ActorUpdateOne {
	auo.mutation.AddUpdatedBy(i)
	return auo
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (auo *ActorUpdateOne) ClearUpdatedBy() *ActorUpdateOne {
	auo.mutation.ClearUpdatedBy()
	return auo
}

// SetType sets the "type" field.
func (auo *ActorUpdateOne) SetType(a actor.Type) *ActorUpdateOne {
	auo.mutation.SetType(a)
	return auo
}

// SetDisplayName sets the "display_name" field.
func (auo *ActorUpdateOne) SetDisplayName(s string) *ActorUpdateOne {
	auo.mutation.SetDisplayName(s)
	return auo
}

// SetNillableDisplayName sets the "display_name" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableDisplayName(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetDisplayName(*s)
	}
	return auo
}

// SetNote sets the "note" field.
func (auo *ActorUpdateOne) SetNote(s string) *ActorUpdateOne {
	auo.mutation.SetNote(s)
	return auo
}

// SetNillableNote sets the "note" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableNote(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetNote(*s)
	}
	return auo
}

// SetLocked sets the "locked" field.
func (auo *ActorUpdateOne) SetLocked(b bool) *ActorUpdateOne {
	auo.mutation.SetLocked(b)
	return auo
}

// SetNillableLocked sets the "locked" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableLocked(b *bool) *ActorUpdateOne {
	if b != nil {
		auo.SetLocked(*b)
	}
	return auo
}

// SetMemorial sets the "memorial" field.
func (auo *ActorUpdateOne) SetMemorial(b bool) *ActorUpdateOne {
	auo.mutation.SetMemorial(b)
	return auo
}

// SetNillableMemorial sets the "memorial" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableMemorial(b *bool) *ActorUpdateOne {
	if b != nil {
		auo.SetMemorial(*b)
	}
	return auo
}

// SetURL sets the "url" field.
func (auo *ActorUpdateOne) SetURL(s string) *ActorUpdateOne {
	auo.mutation.SetURL(s)
	return auo
}

// SetPubkey sets the "pubkey" field.
func (auo *ActorUpdateOne) SetPubkey(b []byte) *ActorUpdateOne {
	auo.mutation.SetPubkey(b)
	return auo
}

// SetPrivkey sets the "privkey" field.
func (auo *ActorUpdateOne) SetPrivkey(b []byte) *ActorUpdateOne {
	auo.mutation.SetPrivkey(b)
	return auo
}

// ClearPrivkey clears the value of the "privkey" field.
func (auo *ActorUpdateOne) ClearPrivkey() *ActorUpdateOne {
	auo.mutation.ClearPrivkey()
	return auo
}

// SetAvatarRemoteURL sets the "avatar_remote_url" field.
func (auo *ActorUpdateOne) SetAvatarRemoteURL(s string) *ActorUpdateOne {
	auo.mutation.SetAvatarRemoteURL(s)
	return auo
}

// SetNillableAvatarRemoteURL sets the "avatar_remote_url" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableAvatarRemoteURL(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetAvatarRemoteURL(*s)
	}
	return auo
}

// ClearAvatarRemoteURL clears the value of the "avatar_remote_url" field.
func (auo *ActorUpdateOne) ClearAvatarRemoteURL() *ActorUpdateOne {
	auo.mutation.ClearAvatarRemoteURL()
	return auo
}

// SetAvatarLocalFile sets the "avatar_local_file" field.
func (auo *ActorUpdateOne) SetAvatarLocalFile(s string) *ActorUpdateOne {
	auo.mutation.SetAvatarLocalFile(s)
	return auo
}

// SetNillableAvatarLocalFile sets the "avatar_local_file" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableAvatarLocalFile(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetAvatarLocalFile(*s)
	}
	return auo
}

// ClearAvatarLocalFile clears the value of the "avatar_local_file" field.
func (auo *ActorUpdateOne) ClearAvatarLocalFile() *ActorUpdateOne {
	auo.mutation.ClearAvatarLocalFile()
	return auo
}

// SetAvatarUpdatedAt sets the "avatar_updated_at" field.
func (auo *ActorUpdateOne) SetAvatarUpdatedAt(t time.Time) *ActorUpdateOne {
	auo.mutation.SetAvatarUpdatedAt(t)
	return auo
}

// SetNillableAvatarUpdatedAt sets the "avatar_updated_at" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableAvatarUpdatedAt(t *time.Time) *ActorUpdateOne {
	if t != nil {
		auo.SetAvatarUpdatedAt(*t)
	}
	return auo
}

// ClearAvatarUpdatedAt clears the value of the "avatar_updated_at" field.
func (auo *ActorUpdateOne) ClearAvatarUpdatedAt() *ActorUpdateOne {
	auo.mutation.ClearAvatarUpdatedAt()
	return auo
}

// SetHeaderURL sets the "header_url" field.
func (auo *ActorUpdateOne) SetHeaderURL(s string) *ActorUpdateOne {
	auo.mutation.SetHeaderURL(s)
	return auo
}

// SetNillableHeaderURL sets the "header_url" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableHeaderURL(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetHeaderURL(*s)
	}
	return auo
}

// ClearHeaderURL clears the value of the "header_url" field.
func (auo *ActorUpdateOne) ClearHeaderURL() *ActorUpdateOne {
	auo.mutation.ClearHeaderURL()
	return auo
}

// SetHeaderLocalFile sets the "header_local_file" field.
func (auo *ActorUpdateOne) SetHeaderLocalFile(s string) *ActorUpdateOne {
	auo.mutation.SetHeaderLocalFile(s)
	return auo
}

// SetNillableHeaderLocalFile sets the "header_local_file" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableHeaderLocalFile(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetHeaderLocalFile(*s)
	}
	return auo
}

// ClearHeaderLocalFile clears the value of the "header_local_file" field.
func (auo *ActorUpdateOne) ClearHeaderLocalFile() *ActorUpdateOne {
	auo.mutation.ClearHeaderLocalFile()
	return auo
}

// SetHeaderUpdatedAt sets the "header_updated_at" field.
func (auo *ActorUpdateOne) SetHeaderUpdatedAt(t time.Time) *ActorUpdateOne {
	auo.mutation.SetHeaderUpdatedAt(t)
	return auo
}

// SetNillableHeaderUpdatedAt sets the "header_updated_at" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableHeaderUpdatedAt(t *time.Time) *ActorUpdateOne {
	if t != nil {
		auo.SetHeaderUpdatedAt(*t)
	}
	return auo
}

// ClearHeaderUpdatedAt clears the value of the "header_updated_at" field.
func (auo *ActorUpdateOne) ClearHeaderUpdatedAt() *ActorUpdateOne {
	auo.mutation.ClearHeaderUpdatedAt()
	return auo
}

// SetLastWebfingerAt sets the "last_webfinger_at" field.
func (auo *ActorUpdateOne) SetLastWebfingerAt(t time.Time) *ActorUpdateOne {
	auo.mutation.SetLastWebfingerAt(t)
	return auo
}

// SetNillableLastWebfingerAt sets the "last_webfinger_at" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableLastWebfingerAt(t *time.Time) *ActorUpdateOne {
	if t != nil {
		auo.SetLastWebfingerAt(*t)
	}
	return auo
}

// ClearLastWebfingerAt clears the value of the "last_webfinger_at" field.
func (auo *ActorUpdateOne) ClearLastWebfingerAt() *ActorUpdateOne {
	auo.mutation.ClearLastWebfingerAt()
	return auo
}

// SetInboxURL sets the "inbox_url" field.
func (auo *ActorUpdateOne) SetInboxURL(s string) *ActorUpdateOne {
	auo.mutation.SetInboxURL(s)
	return auo
}

// SetOutboxURL sets the "outbox_url" field.
func (auo *ActorUpdateOne) SetOutboxURL(s string) *ActorUpdateOne {
	auo.mutation.SetOutboxURL(s)
	return auo
}

// SetSharedInboxURL sets the "shared_inbox_url" field.
func (auo *ActorUpdateOne) SetSharedInboxURL(s string) *ActorUpdateOne {
	auo.mutation.SetSharedInboxURL(s)
	return auo
}

// SetFollowersURL sets the "followers_url" field.
func (auo *ActorUpdateOne) SetFollowersURL(s string) *ActorUpdateOne {
	auo.mutation.SetFollowersURL(s)
	return auo
}

// SetMovedToID sets the "moved_to_id" field.
func (auo *ActorUpdateOne) SetMovedToID(u uint64) *ActorUpdateOne {
	auo.mutation.ResetMovedToID()
	auo.mutation.SetMovedToID(u)
	return auo
}

// SetNillableMovedToID sets the "moved_to_id" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableMovedToID(u *uint64) *ActorUpdateOne {
	if u != nil {
		auo.SetMovedToID(*u)
	}
	return auo
}

// AddMovedToID adds u to the "moved_to_id" field.
func (auo *ActorUpdateOne) AddMovedToID(u int64) *ActorUpdateOne {
	auo.mutation.AddMovedToID(u)
	return auo
}

// ClearMovedToID clears the value of the "moved_to_id" field.
func (auo *ActorUpdateOne) ClearMovedToID() *ActorUpdateOne {
	auo.mutation.ClearMovedToID()
	return auo
}

// SetFeaturedCollectionURL sets the "featured_collection_url" field.
func (auo *ActorUpdateOne) SetFeaturedCollectionURL(s string) *ActorUpdateOne {
	auo.mutation.SetFeaturedCollectionURL(s)
	return auo
}

// SetNillableFeaturedCollectionURL sets the "featured_collection_url" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableFeaturedCollectionURL(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetFeaturedCollectionURL(*s)
	}
	return auo
}

// ClearFeaturedCollectionURL clears the value of the "featured_collection_url" field.
func (auo *ActorUpdateOne) ClearFeaturedCollectionURL() *ActorUpdateOne {
	auo.mutation.ClearFeaturedCollectionURL()
	return auo
}

// SetSilencedAt sets the "silenced_at" field.
func (auo *ActorUpdateOne) SetSilencedAt(t time.Time) *ActorUpdateOne {
	auo.mutation.SetSilencedAt(t)
	return auo
}

// SetNillableSilencedAt sets the "silenced_at" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableSilencedAt(t *time.Time) *ActorUpdateOne {
	if t != nil {
		auo.SetSilencedAt(*t)
	}
	return auo
}

// ClearSilencedAt clears the value of the "silenced_at" field.
func (auo *ActorUpdateOne) ClearSilencedAt() *ActorUpdateOne {
	auo.mutation.ClearSilencedAt()
	return auo
}

// SetSuspendedAt sets the "suspended_at" field.
func (auo *ActorUpdateOne) SetSuspendedAt(t time.Time) *ActorUpdateOne {
	auo.mutation.SetSuspendedAt(t)
	return auo
}

// SetNillableSuspendedAt sets the "suspended_at" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableSuspendedAt(t *time.Time) *ActorUpdateOne {
	if t != nil {
		auo.SetSuspendedAt(*t)
	}
	return auo
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (auo *ActorUpdateOne) ClearSuspendedAt() *ActorUpdateOne {
	auo.mutation.ClearSuspendedAt()
	return auo
}

// SetPasswordHash sets the "passwordHash" field.
func (auo *ActorUpdateOne) SetPasswordHash(b []byte) *ActorUpdateOne {
	auo.mutation.SetPasswordHash(b)
	return auo
}

// ClearPasswordHash clears the value of the "passwordHash" field.
func (auo *ActorUpdateOne) ClearPasswordHash() *ActorUpdateOne {
	auo.mutation.ClearPasswordHash()
	return auo
}

// SetRecoveryCode sets the "recovery_code" field.
func (auo *ActorUpdateOne) SetRecoveryCode(s string) *ActorUpdateOne {
	auo.mutation.SetRecoveryCode(s)
	return auo
}

// SetNillableRecoveryCode sets the "recovery_code" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableRecoveryCode(s *string) *ActorUpdateOne {
	if s != nil {
		auo.SetRecoveryCode(*s)
	}
	return auo
}

// ClearRecoveryCode clears the value of the "recovery_code" field.
func (auo *ActorUpdateOne) ClearRecoveryCode() *ActorUpdateOne {
	auo.mutation.ClearRecoveryCode()
	return auo
}

// SetRole sets the "role" field.
func (auo *ActorUpdateOne) SetRole(u uint64) *ActorUpdateOne {
	auo.mutation.ResetRole()
	auo.mutation.SetRole(u)
	return auo
}

// SetNillableRole sets the "role" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableRole(u *uint64) *ActorUpdateOne {
	if u != nil {
		auo.SetRole(*u)
	}
	return auo
}

// AddRole adds u to the "role" field.
func (auo *ActorUpdateOne) AddRole(u int64) *ActorUpdateOne {
	auo.mutation.AddRole(u)
	return auo
}

// ClearRole clears the value of the "role" field.
func (auo *ActorUpdateOne) ClearRole() *ActorUpdateOne {
	auo.mutation.ClearRole()
	return auo
}

// SetBadge sets the "badge" field.
func (auo *ActorUpdateOne) SetBadge(u uint64) *ActorUpdateOne {
	auo.mutation.ResetBadge()
	auo.mutation.SetBadge(u)
	return auo
}

// SetNillableBadge sets the "badge" field if the given value is not nil.
func (auo *ActorUpdateOne) SetNillableBadge(u *uint64) *ActorUpdateOne {
	if u != nil {
		auo.SetBadge(*u)
	}
	return auo
}

// AddBadge adds u to the "badge" field.
func (auo *ActorUpdateOne) AddBadge(u int64) *ActorUpdateOne {
	auo.mutation.AddBadge(u)
	return auo
}

// ClearBadge clears the value of the "badge" field.
func (auo *ActorUpdateOne) ClearBadge() *ActorUpdateOne {
	auo.mutation.ClearBadge()
	return auo
}

// SetLocale sets the "locale" field.
func (auo *ActorUpdateOne) SetLocale(a actor.Locale) *ActorUpdateOne {
	auo.mutation.SetLocale(a)
	return auo
}

// SetServerID sets the "server" edge to the Server entity by ID.
func (auo *ActorUpdateOne) SetServerID(id uint64) *ActorUpdateOne {
	auo.mutation.SetServerID(id)
	return auo
}

// SetServer sets the "server" edge to the Server entity.
func (auo *ActorUpdateOne) SetServer(s *Server) *ActorUpdateOne {
	return auo.SetServerID(s.ID)
}

// AddEventIDs adds the "events" edge to the Event entity by IDs.
func (auo *ActorUpdateOne) AddEventIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddEventIDs(ids...)
	return auo
}

// AddEvents adds the "events" edges to the Event entity.
func (auo *ActorUpdateOne) AddEvents(e ...*Event) *ActorUpdateOne {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return auo.AddEventIDs(ids...)
}

// AddOrganizerOfIDs adds the "organizer_of" edge to the Event entity by IDs.
func (auo *ActorUpdateOne) AddOrganizerOfIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddOrganizerOfIDs(ids...)
	return auo
}

// AddOrganizerOf adds the "organizer_of" edges to the Event entity.
func (auo *ActorUpdateOne) AddOrganizerOf(e ...*Event) *ActorUpdateOne {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return auo.AddOrganizerOfIDs(ids...)
}

// AddStatusIDs adds the "statuses" edge to the Status entity by IDs.
func (auo *ActorUpdateOne) AddStatusIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddStatusIDs(ids...)
	return auo
}

// AddStatuses adds the "statuses" edges to the Status entity.
func (auo *ActorUpdateOne) AddStatuses(s ...*Status) *ActorUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.AddStatusIDs(ids...)
}

// AddFollowerIDs adds the "followers" edge to the Actor entity by IDs.
func (auo *ActorUpdateOne) AddFollowerIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddFollowerIDs(ids...)
	return auo
}

// AddFollowers adds the "followers" edges to the Actor entity.
func (auo *ActorUpdateOne) AddFollowers(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddFollowerIDs(ids...)
}

// AddFollowingIDs adds the "following" edge to the Actor entity by IDs.
func (auo *ActorUpdateOne) AddFollowingIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddFollowingIDs(ids...)
	return auo
}

// AddFollowing adds the "following" edges to the Actor entity.
func (auo *ActorUpdateOne) AddFollowing(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddFollowingIDs(ids...)
}

// AddReactedStatusIDs adds the "reacted_statuses" edge to the Status entity by IDs.
func (auo *ActorUpdateOne) AddReactedStatusIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddReactedStatusIDs(ids...)
	return auo
}

// AddReactedStatuses adds the "reacted_statuses" edges to the Status entity.
func (auo *ActorUpdateOne) AddReactedStatuses(s ...*Status) *ActorUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.AddReactedStatusIDs(ids...)
}

// AddModeratorIDs adds the "moderators" edge to the Actor entity by IDs.
func (auo *ActorUpdateOne) AddModeratorIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddModeratorIDs(ids...)
	return auo
}

// AddModerators adds the "moderators" edges to the Actor entity.
func (auo *ActorUpdateOne) AddModerators(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddModeratorIDs(ids...)
}

// AddModeratingIDs adds the "moderating" edge to the Actor entity by IDs.
func (auo *ActorUpdateOne) AddModeratingIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddModeratingIDs(ids...)
	return auo
}

// AddModerating adds the "moderating" edges to the Actor entity.
func (auo *ActorUpdateOne) AddModerating(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddModeratingIDs(ids...)
}

// AddMemberIDs adds the "members" edge to the Actor entity by IDs.
func (auo *ActorUpdateOne) AddMemberIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddMemberIDs(ids...)
	return auo
}

// AddMembers adds the "members" edges to the Actor entity.
func (auo *ActorUpdateOne) AddMembers(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddMemberIDs(ids...)
}

// AddGroupIDs adds the "groups" edge to the Actor entity by IDs.
func (auo *ActorUpdateOne) AddGroupIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddGroupIDs(ids...)
	return auo
}

// AddGroups adds the "groups" edges to the Actor entity.
func (auo *ActorUpdateOne) AddGroups(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.AddGroupIDs(ids...)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by IDs.
func (auo *ActorUpdateOne) AddSessionIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.AddSessionIDs(ids...)
	return auo
}

// AddSessions adds the "sessions" edges to the Session entity.
func (auo *ActorUpdateOne) AddSessions(s ...*Session) *ActorUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.AddSessionIDs(ids...)
}

// Mutation returns the ActorMutation object of the builder.
func (auo *ActorUpdateOne) Mutation() *ActorMutation {
	return auo.mutation
}

// ClearServer clears the "server" edge to the Server entity.
func (auo *ActorUpdateOne) ClearServer() *ActorUpdateOne {
	auo.mutation.ClearServer()
	return auo
}

// ClearEvents clears all "events" edges to the Event entity.
func (auo *ActorUpdateOne) ClearEvents() *ActorUpdateOne {
	auo.mutation.ClearEvents()
	return auo
}

// RemoveEventIDs removes the "events" edge to Event entities by IDs.
func (auo *ActorUpdateOne) RemoveEventIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveEventIDs(ids...)
	return auo
}

// RemoveEvents removes "events" edges to Event entities.
func (auo *ActorUpdateOne) RemoveEvents(e ...*Event) *ActorUpdateOne {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return auo.RemoveEventIDs(ids...)
}

// ClearOrganizerOf clears all "organizer_of" edges to the Event entity.
func (auo *ActorUpdateOne) ClearOrganizerOf() *ActorUpdateOne {
	auo.mutation.ClearOrganizerOf()
	return auo
}

// RemoveOrganizerOfIDs removes the "organizer_of" edge to Event entities by IDs.
func (auo *ActorUpdateOne) RemoveOrganizerOfIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveOrganizerOfIDs(ids...)
	return auo
}

// RemoveOrganizerOf removes "organizer_of" edges to Event entities.
func (auo *ActorUpdateOne) RemoveOrganizerOf(e ...*Event) *ActorUpdateOne {
	ids := make([]uint64, len(e))
	for i := range e {
		ids[i] = e[i].ID
	}
	return auo.RemoveOrganizerOfIDs(ids...)
}

// ClearStatuses clears all "statuses" edges to the Status entity.
func (auo *ActorUpdateOne) ClearStatuses() *ActorUpdateOne {
	auo.mutation.ClearStatuses()
	return auo
}

// RemoveStatusIDs removes the "statuses" edge to Status entities by IDs.
func (auo *ActorUpdateOne) RemoveStatusIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveStatusIDs(ids...)
	return auo
}

// RemoveStatuses removes "statuses" edges to Status entities.
func (auo *ActorUpdateOne) RemoveStatuses(s ...*Status) *ActorUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.RemoveStatusIDs(ids...)
}

// ClearFollowers clears all "followers" edges to the Actor entity.
func (auo *ActorUpdateOne) ClearFollowers() *ActorUpdateOne {
	auo.mutation.ClearFollowers()
	return auo
}

// RemoveFollowerIDs removes the "followers" edge to Actor entities by IDs.
func (auo *ActorUpdateOne) RemoveFollowerIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveFollowerIDs(ids...)
	return auo
}

// RemoveFollowers removes "followers" edges to Actor entities.
func (auo *ActorUpdateOne) RemoveFollowers(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveFollowerIDs(ids...)
}

// ClearFollowing clears all "following" edges to the Actor entity.
func (auo *ActorUpdateOne) ClearFollowing() *ActorUpdateOne {
	auo.mutation.ClearFollowing()
	return auo
}

// RemoveFollowingIDs removes the "following" edge to Actor entities by IDs.
func (auo *ActorUpdateOne) RemoveFollowingIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveFollowingIDs(ids...)
	return auo
}

// RemoveFollowing removes "following" edges to Actor entities.
func (auo *ActorUpdateOne) RemoveFollowing(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveFollowingIDs(ids...)
}

// ClearReactedStatuses clears all "reacted_statuses" edges to the Status entity.
func (auo *ActorUpdateOne) ClearReactedStatuses() *ActorUpdateOne {
	auo.mutation.ClearReactedStatuses()
	return auo
}

// RemoveReactedStatusIDs removes the "reacted_statuses" edge to Status entities by IDs.
func (auo *ActorUpdateOne) RemoveReactedStatusIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveReactedStatusIDs(ids...)
	return auo
}

// RemoveReactedStatuses removes "reacted_statuses" edges to Status entities.
func (auo *ActorUpdateOne) RemoveReactedStatuses(s ...*Status) *ActorUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.RemoveReactedStatusIDs(ids...)
}

// ClearModerators clears all "moderators" edges to the Actor entity.
func (auo *ActorUpdateOne) ClearModerators() *ActorUpdateOne {
	auo.mutation.ClearModerators()
	return auo
}

// RemoveModeratorIDs removes the "moderators" edge to Actor entities by IDs.
func (auo *ActorUpdateOne) RemoveModeratorIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveModeratorIDs(ids...)
	return auo
}

// RemoveModerators removes "moderators" edges to Actor entities.
func (auo *ActorUpdateOne) RemoveModerators(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveModeratorIDs(ids...)
}

// ClearModerating clears all "moderating" edges to the Actor entity.
func (auo *ActorUpdateOne) ClearModerating() *ActorUpdateOne {
	auo.mutation.ClearModerating()
	return auo
}

// RemoveModeratingIDs removes the "moderating" edge to Actor entities by IDs.
func (auo *ActorUpdateOne) RemoveModeratingIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveModeratingIDs(ids...)
	return auo
}

// RemoveModerating removes "moderating" edges to Actor entities.
func (auo *ActorUpdateOne) RemoveModerating(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveModeratingIDs(ids...)
}

// ClearMembers clears all "members" edges to the Actor entity.
func (auo *ActorUpdateOne) ClearMembers() *ActorUpdateOne {
	auo.mutation.ClearMembers()
	return auo
}

// RemoveMemberIDs removes the "members" edge to Actor entities by IDs.
func (auo *ActorUpdateOne) RemoveMemberIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveMemberIDs(ids...)
	return auo
}

// RemoveMembers removes "members" edges to Actor entities.
func (auo *ActorUpdateOne) RemoveMembers(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveMemberIDs(ids...)
}

// ClearGroups clears all "groups" edges to the Actor entity.
func (auo *ActorUpdateOne) ClearGroups() *ActorUpdateOne {
	auo.mutation.ClearGroups()
	return auo
}

// RemoveGroupIDs removes the "groups" edge to Actor entities by IDs.
func (auo *ActorUpdateOne) RemoveGroupIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveGroupIDs(ids...)
	return auo
}

// RemoveGroups removes "groups" edges to Actor entities.
func (auo *ActorUpdateOne) RemoveGroups(a ...*Actor) *ActorUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return auo.RemoveGroupIDs(ids...)
}

// ClearSessions clears all "sessions" edges to the Session entity.
func (auo *ActorUpdateOne) ClearSessions() *ActorUpdateOne {
	auo.mutation.ClearSessions()
	return auo
}

// RemoveSessionIDs removes the "sessions" edge to Session entities by IDs.
func (auo *ActorUpdateOne) RemoveSessionIDs(ids ...uint64) *ActorUpdateOne {
	auo.mutation.RemoveSessionIDs(ids...)
	return auo
}

// RemoveSessions removes "sessions" edges to Session entities.
func (auo *ActorUpdateOne) RemoveSessions(s ...*Session) *ActorUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.RemoveSessionIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (auo *ActorUpdateOne) Select(field string, fields ...string) *ActorUpdateOne {
	auo.fields = append([]string{field}, fields...)
	return auo
}

// Save executes the query and returns the updated Actor entity.
func (auo *ActorUpdateOne) Save(ctx context.Context) (*Actor, error) {
	var (
		err  error
		node *Actor
	)
	if err := auo.defaults(); err != nil {
		return nil, err
	}
	if len(auo.hooks) == 0 {
		if err = auo.check(); err != nil {
			return nil, err
		}
		node, err = auo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*ActorMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = auo.check(); err != nil {
				return nil, err
			}
			auo.mutation = mutation
			node, err = auo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(auo.hooks) - 1; i >= 0; i-- {
			if auo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = auo.hooks[i](mut)
		}
		v, err := mut.Mutate(ctx, auo.mutation)
		if err != nil {
			return nil, err
		}
		nv, ok := v.(*Actor)
		if !ok {
			return nil, fmt.Errorf("unexpected node type %T returned from ActorMutation", v)
		}
		node = nv
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (auo *ActorUpdateOne) SaveX(ctx context.Context) *Actor {
	node, err := auo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (auo *ActorUpdateOne) Exec(ctx context.Context) error {
	_, err := auo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (auo *ActorUpdateOne) ExecX(ctx context.Context) {
	if err := auo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (auo *ActorUpdateOne) defaults() error {
	if _, ok := auo.mutation.UpdatedAt(); !ok {
		if actor.UpdateDefaultUpdatedAt == nil {
			return fmt.Errorf("ent: uninitialized actor.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
		}
		v := actor.UpdateDefaultUpdatedAt()
		auo.mutation.SetUpdatedAt(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (auo *ActorUpdateOne) check() error {
	if v, ok := auo.mutation.GetType(); ok {
		if err := actor.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Actor.type": %w`, err)}
		}
	}
	if v, ok := auo.mutation.DisplayName(); ok {
		if err := actor.DisplayNameValidator(v); err != nil {
			return &ValidationError{Name: "display_name", err: fmt.Errorf(`ent: validator failed for field "Actor.display_name": %w`, err)}
		}
	}
	if v, ok := auo.mutation.Note(); ok {
		if err := actor.NoteValidator(v); err != nil {
			return &ValidationError{Name: "note", err: fmt.Errorf(`ent: validator failed for field "Actor.note": %w`, err)}
		}
	}
	if v, ok := auo.mutation.URL(); ok {
		if err := actor.URLValidator(v); err != nil {
			return &ValidationError{Name: "url", err: fmt.Errorf(`ent: validator failed for field "Actor.url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.Pubkey(); ok {
		if err := actor.PubkeyValidator(v); err != nil {
			return &ValidationError{Name: "pubkey", err: fmt.Errorf(`ent: validator failed for field "Actor.pubkey": %w`, err)}
		}
	}
	if v, ok := auo.mutation.AvatarRemoteURL(); ok {
		if err := actor.AvatarRemoteURLValidator(v); err != nil {
			return &ValidationError{Name: "avatar_remote_url", err: fmt.Errorf(`ent: validator failed for field "Actor.avatar_remote_url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.AvatarLocalFile(); ok {
		if err := actor.AvatarLocalFileValidator(v); err != nil {
			return &ValidationError{Name: "avatar_local_file", err: fmt.Errorf(`ent: validator failed for field "Actor.avatar_local_file": %w`, err)}
		}
	}
	if v, ok := auo.mutation.HeaderURL(); ok {
		if err := actor.HeaderURLValidator(v); err != nil {
			return &ValidationError{Name: "header_url", err: fmt.Errorf(`ent: validator failed for field "Actor.header_url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.HeaderLocalFile(); ok {
		if err := actor.HeaderLocalFileValidator(v); err != nil {
			return &ValidationError{Name: "header_local_file", err: fmt.Errorf(`ent: validator failed for field "Actor.header_local_file": %w`, err)}
		}
	}
	if v, ok := auo.mutation.InboxURL(); ok {
		if err := actor.InboxURLValidator(v); err != nil {
			return &ValidationError{Name: "inbox_url", err: fmt.Errorf(`ent: validator failed for field "Actor.inbox_url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.OutboxURL(); ok {
		if err := actor.OutboxURLValidator(v); err != nil {
			return &ValidationError{Name: "outbox_url", err: fmt.Errorf(`ent: validator failed for field "Actor.outbox_url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.SharedInboxURL(); ok {
		if err := actor.SharedInboxURLValidator(v); err != nil {
			return &ValidationError{Name: "shared_inbox_url", err: fmt.Errorf(`ent: validator failed for field "Actor.shared_inbox_url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.FollowersURL(); ok {
		if err := actor.FollowersURLValidator(v); err != nil {
			return &ValidationError{Name: "followers_url", err: fmt.Errorf(`ent: validator failed for field "Actor.followers_url": %w`, err)}
		}
	}
	if v, ok := auo.mutation.PasswordHash(); ok {
		if err := actor.PasswordHashValidator(v); err != nil {
			return &ValidationError{Name: "passwordHash", err: fmt.Errorf(`ent: validator failed for field "Actor.passwordHash": %w`, err)}
		}
	}
	if v, ok := auo.mutation.Locale(); ok {
		if err := actor.LocaleValidator(v); err != nil {
			return &ValidationError{Name: "locale", err: fmt.Errorf(`ent: validator failed for field "Actor.locale": %w`, err)}
		}
	}
	if _, ok := auo.mutation.ServerID(); auo.mutation.ServerCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "Actor.server"`)
	}
	return nil
}

func (auo *ActorUpdateOne) sqlSave(ctx context.Context) (_node *Actor, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   actor.Table,
			Columns: actor.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUint64,
				Column: actor.FieldID,
			},
		},
	}
	id, ok := auo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Actor.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := auo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, actor.FieldID)
		for _, f := range fields {
			if !actor.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != actor.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := auo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := auo.mutation.UpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldUpdatedAt,
		})
	}
	if value, ok := auo.mutation.CreatedBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldCreatedBy,
		})
	}
	if value, ok := auo.mutation.AddedCreatedBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldCreatedBy,
		})
	}
	if auo.mutation.CreatedByCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: actor.FieldCreatedBy,
		})
	}
	if value, ok := auo.mutation.UpdatedBy(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldUpdatedBy,
		})
	}
	if value, ok := auo.mutation.AddedUpdatedBy(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: actor.FieldUpdatedBy,
		})
	}
	if auo.mutation.UpdatedByCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: actor.FieldUpdatedBy,
		})
	}
	if value, ok := auo.mutation.GetType(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: actor.FieldType,
		})
	}
	if value, ok := auo.mutation.DisplayName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldDisplayName,
		})
	}
	if value, ok := auo.mutation.Note(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldNote,
		})
	}
	if value, ok := auo.mutation.Locked(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: actor.FieldLocked,
		})
	}
	if value, ok := auo.mutation.Memorial(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  value,
			Column: actor.FieldMemorial,
		})
	}
	if value, ok := auo.mutation.URL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldURL,
		})
	}
	if value, ok := auo.mutation.Pubkey(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Value:  value,
			Column: actor.FieldPubkey,
		})
	}
	if value, ok := auo.mutation.Privkey(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Value:  value,
			Column: actor.FieldPrivkey,
		})
	}
	if auo.mutation.PrivkeyCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Column: actor.FieldPrivkey,
		})
	}
	if value, ok := auo.mutation.AvatarRemoteURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldAvatarRemoteURL,
		})
	}
	if auo.mutation.AvatarRemoteURLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldAvatarRemoteURL,
		})
	}
	if value, ok := auo.mutation.AvatarLocalFile(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldAvatarLocalFile,
		})
	}
	if auo.mutation.AvatarLocalFileCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldAvatarLocalFile,
		})
	}
	if value, ok := auo.mutation.AvatarUpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldAvatarUpdatedAt,
		})
	}
	if auo.mutation.AvatarUpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldAvatarUpdatedAt,
		})
	}
	if value, ok := auo.mutation.HeaderURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldHeaderURL,
		})
	}
	if auo.mutation.HeaderURLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldHeaderURL,
		})
	}
	if value, ok := auo.mutation.HeaderLocalFile(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldHeaderLocalFile,
		})
	}
	if auo.mutation.HeaderLocalFileCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldHeaderLocalFile,
		})
	}
	if value, ok := auo.mutation.HeaderUpdatedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldHeaderUpdatedAt,
		})
	}
	if auo.mutation.HeaderUpdatedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldHeaderUpdatedAt,
		})
	}
	if value, ok := auo.mutation.LastWebfingerAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldLastWebfingerAt,
		})
	}
	if auo.mutation.LastWebfingerAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldLastWebfingerAt,
		})
	}
	if value, ok := auo.mutation.InboxURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldInboxURL,
		})
	}
	if value, ok := auo.mutation.OutboxURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldOutboxURL,
		})
	}
	if value, ok := auo.mutation.SharedInboxURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldSharedInboxURL,
		})
	}
	if value, ok := auo.mutation.FollowersURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldFollowersURL,
		})
	}
	if value, ok := auo.mutation.MovedToID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldMovedToID,
		})
	}
	if value, ok := auo.mutation.AddedMovedToID(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldMovedToID,
		})
	}
	if auo.mutation.MovedToIDCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Column: actor.FieldMovedToID,
		})
	}
	if value, ok := auo.mutation.FeaturedCollectionURL(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldFeaturedCollectionURL,
		})
	}
	if auo.mutation.FeaturedCollectionURLCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldFeaturedCollectionURL,
		})
	}
	if value, ok := auo.mutation.SilencedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldSilencedAt,
		})
	}
	if auo.mutation.SilencedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldSilencedAt,
		})
	}
	if value, ok := auo.mutation.SuspendedAt(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: actor.FieldSuspendedAt,
		})
	}
	if auo.mutation.SuspendedAtCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: actor.FieldSuspendedAt,
		})
	}
	if value, ok := auo.mutation.PasswordHash(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Value:  value,
			Column: actor.FieldPasswordHash,
		})
	}
	if auo.mutation.PasswordHashCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBytes,
			Column: actor.FieldPasswordHash,
		})
	}
	if value, ok := auo.mutation.RecoveryCode(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: actor.FieldRecoveryCode,
		})
	}
	if auo.mutation.RecoveryCodeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: actor.FieldRecoveryCode,
		})
	}
	if value, ok := auo.mutation.Role(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldRole,
		})
	}
	if value, ok := auo.mutation.AddedRole(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldRole,
		})
	}
	if auo.mutation.RoleCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Column: actor.FieldRole,
		})
	}
	if value, ok := auo.mutation.Badge(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldBadge,
		})
	}
	if value, ok := auo.mutation.AddedBadge(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Value:  value,
			Column: actor.FieldBadge,
		})
	}
	if auo.mutation.BadgeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeUint64,
			Column: actor.FieldBadge,
		})
	}
	if value, ok := auo.mutation.Locale(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeEnum,
			Value:  value,
			Column: actor.FieldLocale,
		})
	}
	if auo.mutation.ServerCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   actor.ServerTable,
			Columns: []string{actor.ServerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: server.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.ServerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   actor.ServerTable,
			Columns: []string{actor.ServerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: server.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.EventsTable,
			Columns: actor.EventsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedEventsIDs(); len(nodes) > 0 && !auo.mutation.EventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.EventsTable,
			Columns: actor.EventsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.EventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.EventsTable,
			Columns: actor.EventsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.OrganizerOfCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.OrganizerOfTable,
			Columns: []string{actor.OrganizerOfColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedOrganizerOfIDs(); len(nodes) > 0 && !auo.mutation.OrganizerOfCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.OrganizerOfTable,
			Columns: []string{actor.OrganizerOfColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.OrganizerOfIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.OrganizerOfTable,
			Columns: []string{actor.OrganizerOfColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: event.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.StatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.StatusesTable,
			Columns: []string{actor.StatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedStatusesIDs(); len(nodes) > 0 && !auo.mutation.StatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.StatusesTable,
			Columns: []string{actor.StatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.StatusesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.StatusesTable,
			Columns: []string{actor.StatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.FollowersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.FollowersTable,
			Columns: actor.FollowersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedFollowersIDs(); len(nodes) > 0 && !auo.mutation.FollowersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.FollowersTable,
			Columns: actor.FollowersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.FollowersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.FollowersTable,
			Columns: actor.FollowersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.FollowingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.FollowingTable,
			Columns: actor.FollowingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedFollowingIDs(); len(nodes) > 0 && !auo.mutation.FollowingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.FollowingTable,
			Columns: actor.FollowingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.FollowingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.FollowingTable,
			Columns: actor.FollowingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.ReactedStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ReactedStatusesTable,
			Columns: actor.ReactedStatusesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		createE := &ReactionCreate{config: auo.config, mutation: newReactionMutation(auo.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedReactedStatusesIDs(); len(nodes) > 0 && !auo.mutation.ReactedStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ReactedStatusesTable,
			Columns: actor.ReactedStatusesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: auo.config, mutation: newReactionMutation(auo.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.ReactedStatusesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ReactedStatusesTable,
			Columns: actor.ReactedStatusesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: status.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: auo.config, mutation: newReactionMutation(auo.config, OpCreate)}
		_ = createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.ModeratorsTable,
			Columns: actor.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedModeratorsIDs(); len(nodes) > 0 && !auo.mutation.ModeratorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.ModeratorsTable,
			Columns: actor.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.ModeratorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.ModeratorsTable,
			Columns: actor.ModeratorsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.ModeratingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ModeratingTable,
			Columns: actor.ModeratingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedModeratingIDs(); len(nodes) > 0 && !auo.mutation.ModeratingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ModeratingTable,
			Columns: actor.ModeratingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.ModeratingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.ModeratingTable,
			Columns: actor.ModeratingPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.MembersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.MembersTable,
			Columns: actor.MembersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedMembersIDs(); len(nodes) > 0 && !auo.mutation.MembersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.MembersTable,
			Columns: actor.MembersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.MembersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   actor.MembersTable,
			Columns: actor.MembersPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.GroupsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.GroupsTable,
			Columns: actor.GroupsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedGroupsIDs(); len(nodes) > 0 && !auo.mutation.GroupsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.GroupsTable,
			Columns: actor.GroupsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.GroupsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   actor.GroupsTable,
			Columns: actor.GroupsPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: actor.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.SessionsTable,
			Columns: []string{actor.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: session.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedSessionsIDs(); len(nodes) > 0 && !auo.mutation.SessionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.SessionsTable,
			Columns: []string{actor.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: session.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.SessionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   actor.SessionsTable,
			Columns: []string{actor.SessionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: session.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Actor{config: auo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, auo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{actor.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	return _node, nil
}
